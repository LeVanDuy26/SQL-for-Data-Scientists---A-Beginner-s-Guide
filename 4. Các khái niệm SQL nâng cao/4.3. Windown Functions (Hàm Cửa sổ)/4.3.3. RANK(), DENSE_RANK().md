### I. Khái niệm và Mục đích chung

`RANK()` và `DENSE_RANK()` là hai hàm cửa sổ có cú pháp rất giống với hàm `ROW_NUMBER()`. Chúng đều được sử dụng để gán một thứ hạng cho mỗi hàng trong một tập hợp các bản ghi (partition).

*   **Bối cảnh chung:** Cả hai hàm này đều hoạt động trên nhiều bản ghi nhưng **không làm nhóm các bản ghi đó lại trong kết quả đầu ra** (unaggregated output), cho phép người dùng duy trì thông tin chi tiết cấp hàng.
*   **Mệnh đề `OVER`:** Giống như tất cả các Hàm Cửa sổ khác, `RANK()` và `DENSE_RANK()` yêu cầu cú pháp `OVER (PARTITION BY ... ORDER BY ...)` để xác định tập hợp các hàng (cửa sổ) mà hàm sẽ hoạt động và thứ tự sắp xếp (sort order) để xác định thứ hạng.

### II. Phân biệt giữa RANK() và DENSE_RANK()

Sự khác biệt chính giữa hai hàm này và `ROW_NUMBER()` nằm ở cách chúng xử lý các trường hợp **hòa (tie)**:

#### 1. Hàm `RANK()`

*   **Cách xử lý hòa:** `RANK()` gán cùng một thứ hạng cho các hàng có cùng giá trị trong cột được sử dụng để sắp xếp.
*   **Khoảng cách xếp hạng:** Khi xảy ra trường hợp hòa, `RANK()` **bỏ qua (skipping)** các số hạng tiếp theo.
*   **Ví dụ về kết quả:** Nếu có hai hàng hòa nhau ở vị trí thứ 2, thứ hạng sẽ là **1, 2, 2, 4** (bỏ qua thứ hạng 3).
*   **Ứng dụng:** Nếu truy vấn được nhúng bên trong một truy vấn con (subquery) và được lọc để chỉ trả về `price_rank = 1`, `RANK()` sẽ trả về **nhiều hàng** cho mỗi nhà cung cấp (vendor) nếu có nhiều sản phẩm có cùng giá cao nhất.

#### 2. Hàm `DENSE_RANK()`

*   **Cách xử lý hòa:** `DENSE_RANK()` gán cùng một thứ hạng cho các hàng có cùng giá trị, tương tự như `RANK()`.
*   **Khoảng cách xếp hạng:** Khi xảy ra trường hợp hòa, `DENSE_RANK()` **không bỏ qua** các số hạng tiếp theo.
*   **Ví dụ về kết quả:** Nếu có hai hàng hòa nhau ở vị trí thứ 2, thứ hạng sẽ là **1, 2, 2, 3**.
*   **Ứng dụng:** Nếu người dùng không muốn có bất kỳ sự bỏ qua số hạng nào khi có sự trùng lặp giá trị, họ nên sử dụng `DENSE_RANK()`. Hàm này cũng được đề xuất trong một bài tập để đánh số lần truy cập thị trường của khách hàng, đảm bảo rằng mỗi ngày thị trường duy nhất sẽ được đánh số thứ hạng tiếp theo, ngay cả khi nhiều giao dịch xảy ra trong cùng một ngày.

### III. Cú pháp và Cách sử dụng

Cú pháp của `RANK()` và `DENSE_RANK()` giống hệt nhau, chỉ khác ở tên hàm:

```sql
RANK() OVER (PARTITION BY [cột phân vùng] ORDER BY [cột sắp xếp])
DENSE_RANK() OVER (PARTITION BY [cột phân vùng] ORDER BY [cột sắp xếp])
```

*   **PARTITION BY:** Chia tập dữ liệu thành các nhóm độc lập (ví dụ: `PARTITION BY vendor_id` để xếp hạng các sản phẩm riêng biệt cho mỗi nhà cung cấp).
*   **ORDER BY:** Xác định thứ tự sắp xếp trong mỗi phân vùng để gán thứ hạng (ví dụ: `ORDER BY original_price DESC` để gán thứ hạng 1 cho giá cao nhất).

### IV. Sự cần thiết của Truy vấn con (Subqueries)

Giống như `ROW_NUMBER()`, `RANK()` và `DENSE_RANK()` được tính toán trên toàn bộ tập dữ liệu hoặc phân vùng **trước** khi mệnh đề `WHERE` được áp dụng.

Do đó, nếu mục đích là **lọc** kết quả dựa trên thứ hạng (ví dụ: chỉ muốn xem các hàng có thứ hạng 1), người dùng phải:

1.  Đưa truy vấn chứa hàm xếp hạng (`RANK()` hoặc `DENSE_RANK()`) vào **Truy vấn Con** (Subquery).
2.  Gán biệt danh (alias) cho truy vấn con đó (ví dụ: `x`).
3.  Sử dụng mệnh đề `WHERE` trong **Truy vấn Ngoài (Outer Query)** để lọc kết quả dựa trên cột xếp hạng đã tính toán (ví dụ: `WHERE x.price_rank = 1`).

Nếu sử dụng `RANK()` cho mục đích này, truy vấn ngoài sẽ trả về tất cả các hàng có thứ hạng 1, bao gồm cả các trường hợp hòa nhau, đảm bảo rằng tất cả các sản phẩm có cùng giá cao nhất (cao nhất trong partition) đều được hiển thị.

### V. So sánh với ROW_NUMBER()

*   **`ROW_NUMBER()`** được sử dụng khi cần một số thứ tự **duy nhất** cho mỗi hàng, ngay cả khi có sự trùng lặp về giá trị.
*   **`RANK()` và `DENSE_RANK()`** được sử dụng khi cần xử lý các trường hợp **hòa (tie)**, cho phép các hàng có giá trị trùng lặp nhận cùng một thứ hạng.