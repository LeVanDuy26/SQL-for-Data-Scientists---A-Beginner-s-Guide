### I. Khái niệm và Mục đích

Cả `LAG()` và `LEAD()` đều là các Hàm Cửa sổ (Window Functions) được thiết kế để truy xuất giá trị từ một hàng khác có liên quan đến hàng hiện tại trong cùng một phân vùng (partition) của tập dữ liệu.

*   **Mục đích:** Các hàm này cho phép người dùng đưa thông tin từ một bản ghi trong quá khứ (`LAG`) hoặc tương lai (`LEAD`) vào bản ghi hiện tại.
*   **Ứng dụng quan trọng:** Chúng đặc biệt hữu ích cho việc tính toán **sự thay đổi của một giá trị theo thời gian** (ví dụ: so sánh tổng doanh số tuần này với tuần trước).

### II. Hàm `LAG()` (Truy xuất giá trị từ quá khứ)

Hàm `LAG()` truy xuất dữ liệu từ một hàng **trước đó** (past record) trong tập dữ liệu, dựa trên thứ tự sắp xếp được chỉ định.

#### 1. Cú pháp và Tham số
Cú pháp của `LAG()` bao gồm việc chỉ định cột muốn truy xuất và offset (số lượng hàng lùi lại):

```sql
LAG([cột], [offset]) OVER (PARTITION BY [phân vùng] ORDER BY [sắp xếp])
```

*   **`[offset]`:** Là số nguyên $x$ chỉ định số hàng lùi lại để lấy giá trị (ví dụ: `LAG(booth_number, 1)` lấy giá trị của hàng ngay trước đó).
*   **Giá trị cho hàng đầu tiên:** Đối với hàng đầu tiên trong mỗi phân vùng, do không có hàng nào đứng trước theo thứ tự sắp xếp, hàm `LAG()` sẽ trả về giá trị **`NULL`**.

#### 2. Ví dụ về Ứng dụng
Tài liệu cung cấp ví dụ sử dụng `LAG()` để so sánh các lần gán gian hàng (`booth_number`) của cùng một nhà cung cấp (`vendor_id`) giữa các ngày thị trường (`market_date`) liên tiếp:

*   Truy vấn sử dụng `LAG(booth_number, 1) OVER (PARTITION BY vendor_id ORDER BY market_date, vendor_id)` để kéo `booth_number` của lần gán trước đó.
*   Kết quả cho thấy giá trị `NULL` cho ngày thị trường đầu tiên và giá trị của lần gán gian hàng trước đó cho các ngày tiếp theo.

### III. Hàm `LEAD()` (Truy xuất giá trị từ tương lai)

Hàm `LEAD()` hoạt động tương tự như `LAG()`, nhưng nó truy xuất giá trị từ một hàng **tiếp theo** (next row) trong tập dữ liệu, theo thứ tự sắp xếp đã chỉ định.

*   **Cơ chế:** Nếu các hàng được sắp xếp theo giá trị thời gian, `LEAD()` sẽ truy xuất dữ liệu từ **tương lai** so với hàng hiện tại.
*   **Ứng dụng:** Thường được sử dụng để xác định thời gian giữa các sự kiện. Ví dụ: tìm ngày mua hàng tiếp theo của khách hàng (`next_purchase`) để tính khoảng cách giữa các lần mua hàng.

#### 1. Thay thế cho LAG()
Trong một bài tập, tác giả chỉ ra rằng `LEAD()` có thể tạo ra kết quả giống hệt như `LAG()` nếu thứ tự sắp xếp (trong mệnh đề `OVER`) được đảo ngược. Cụ thể, nếu bạn muốn so sánh với ngày trước đó, bạn có thể dùng `LEAD()` và sắp xếp ngày giảm dần (`ORDER BY market_date DESC`), điều này sẽ đặt hàng trước đó vào vị trí "tiếp theo" trong thứ tự sắp xếp ngược.

### IV. Cú pháp Xác định Cửa sổ (Windowing Clause)

Giống như các Hàm Cửa sổ khác, cả `LAG()` và `LEAD()` đều yêu cầu cú pháp `OVER()` để định nghĩa phạm vi tính toán và thứ tự dữ liệu.

*   **`PARTITION BY`:** Chia dữ liệu thành các nhóm độc lập (ví dụ: `PARTITION BY customer_id` để đảm bảo việc truy xuất giá trị trước/sau chỉ xảy ra trong phạm vi các giao dịch của cùng một khách hàng).
*   **`ORDER BY`:** **Bắt buộc**, xác định thứ tự mà hàm sẽ đếm các hàng trước đó (`LAG`) hoặc hàng tiếp theo (`LEAD`). Thứ tự này phải hợp lý (ví dụ: sắp xếp theo ngày tháng hoặc thời gian giao dịch).

### V. Ứng dụng Nâng cao với Truy vấn Con (Subqueries)

Khi sử dụng `LAG()` hoặc `LEAD()` để tính toán các thay đổi hoặc so sánh, người dùng thường cần sử dụng **Truy vấn Con (Subqueries)** để lọc hoặc thao tác trên kết quả được trả về:

1.  **Lọc Thay đổi Trạng thái:** Trong ví dụ về gán gian hàng, sau khi tính toán `previous_booth_number` bằng `LAG()` trong truy vấn con, truy vấn ngoài có thể lọc để chỉ trả về các hàng mà `booth_number` hiện tại **khác** với `previous_booth_number` (hoặc `previous_booth_number` là `NULL` cho các nhà cung cấp mới).
2.  **Tính toán Khoảng thời gian:** `LEAD()` thường được sử dụng bên trong hàm `DATEDIFF()` để tính khoảng thời gian giữa hai ngày liên tiếp (ví dụ: `DATEDIFF(LEAD(next_purchase), market_date)` tính số ngày giữa lần mua hàng hiện tại và lần mua hàng tiếp theo).
3.  **Tính toán trên Dữ liệu đã Tổng hợp:** `LAG()` có thể được sử dụng trên kết quả đã được tổng hợp bằng `GROUP BY` thông thường. Ví dụ: tính tổng doanh số theo ngày, sau đó áp dụng `LAG(SUM(...), 1)` để kéo tổng doanh số của ngày trước đó. Trong trường hợp này, các Hàm Cửa sổ được tính toán **sau khi** việc nhóm và tổng hợp xảy ra.