### I. Lý do Truy vấn Con là Bắt buộc (Thứ tự Thực thi Truy vấn)

Vấn đề cốt lõi khiến Truy vấn Con trở nên cần thiết nằm ở **thứ tự thực thi (execution order)** các mệnh đề trong truy vấn SQL.

1.  **Hàm Cửa sổ được Tính toán Sau:** Các Hàm Cửa sổ, bao gồm các hàm xếp hạng như `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `NTILE()`, và các hàm tổng hợp dạng cửa sổ (Aggregate Window Functions) như `SUM()` hay `AVG()` đi kèm với mệnh đề `OVER()`, được tính toán trên toàn bộ tập dữ liệu hoặc phân vùng (**Partition**) **trước** khi các mệnh đề lọc hàng (`WHERE`) được áp dụng.
2.  **Mệnh đề `WHERE` được Tính toán Sớm hơn:** Mệnh đề `WHERE` được đánh giá dựa trên từng hàng riêng lẻ (row by row). Tại thời điểm mệnh đề `WHERE` được xử lý, giá trị của cột được tạo ra bởi Hàm Cửa sổ (ví dụ: cột `price_rank` hoặc `average_cost_product_by_market_date`) **chưa được xác định hoặc tính toán đầy đủ** cho toàn bộ tập dữ liệu.
3.  **Lỗi Cú pháp:** Nếu người dùng cố gắng tham chiếu đến biệt danh (alias) của cột Hàm Cửa sổ (ví dụ: `price_rank`) trong mệnh đề `WHERE` của truy vấn gốc, SQL sẽ trả về lỗi, bởi vì giá trị đó vẫn còn "chưa rõ" (unknown) tại thời điểm `WHERE` được xử lý.

### II. Giải pháp: Sử dụng Truy vấn Con (Subquery/Derived Table)

Để khắc phục giới hạn về thứ tự thực thi này, nhà khoa học dữ liệu phải sử dụng cấu trúc **Truy vấn Con (Subquery)**.

#### 1. Cơ chế hoạt động của Truy vấn Con
Truy vấn Con (hay còn gọi là "truy vấn từ một bảng phái sinh" - derived table) hoạt động như sau:

*   **Truy vấn Nội bộ (Inner Query):** Truy vấn nằm bên trong dấu ngoặc đơn (`inner SELECT statement`) thực hiện toàn bộ công việc tính toán Hàm Cửa sổ (`ROW_NUMBER() OVER (...) AS price_rank`).
*   **Kết thúc Tính toán:** Khi truy vấn nội bộ hoàn tất, nó trả về một **tập kết quả đầy đủ**, bao gồm cột mới được tạo ra bởi Hàm Cửa sổ.
*   **Truy vấn Bên ngoài (Outer Query):** Truy vấn nằm ngoài dấu ngoặc đơn (`outer SELECT statement`) xem kết quả của truy vấn nội bộ như là một **bảng tạm thời (table)**. Bảng tạm thời này phải được đặt một biệt danh (alias), ví dụ như `x`.
*   **Lọc Kết quả:** Truy vấn bên ngoài sau đó có thể truy vấn từ "bảng" `x` này và sử dụng mệnh đề `WHERE` để lọc kết quả dựa trên giá trị của cột Hàm Cửa sổ đã được tính toán.

#### 2. Ví dụ Cú pháp

Để tìm sản phẩm đắt nhất (`price_rank = 1`) trong mỗi nhà cung cấp (vendor), truy vấn phải được cấu trúc như sau:

```sql
SELECT * FROM (
    SELECT
        vendor_id,
        market_date,
        product_id,
        original_price,
        ROW_NUMBER() OVER (PARTITION BY vendor_id ORDER BY original_price DESC) AS price_rank -- Hàm cửa sổ được tính ở đây
    FROM farmers_market.vendor_inventory
    ORDER BY vendor_id
) x -- Bảng phái sinh được đặt biệt danh là 'x'
WHERE x.price_rank = 1 -- Lọc trên giá trị đã được tính toán trong truy vấn ngoài
```

#### 3. Ứng dụng Bắt buộc cho các Hàm Khác
Nguyên tắc này áp dụng cho tất cả các tình huống lọc kết quả Hàm Cửa sổ:

*   **Lọc xếp hạng:** Lọc để chỉ trả về hàng có `price_rank = 1` (ví dụ: sản phẩm đắt nhất).
*   **Lọc tổng hợp:** Lọc các sản phẩm có giá cao hơn mức trung bình của thị trường (`x.original_price > x.average_cost_product_by_market_date`), trong đó giá trung bình được tính bằng Hàm Cửa sổ `AVG()`.
*   **Lọc thay đổi trạng thái:** Lọc các nhà cung cấp có `booth_number` hiện tại khác với `previous_booth_number` (được tính bằng `LAG()`).

### III. Lời khuyên về Gỡ lỗi

Tài liệu khuyến nghị rằng nhiều trình soạn thảo SQL cho phép người dùng **chạy riêng truy vấn nội bộ** (`inner query`) bằng cách làm nổi bật và thực thi phần SQL đó. Việc này rất hữu ích để xem trước kết quả, giúp người phân tích xác nhận rằng Hàm Cửa sổ đã tính toán giá trị một cách chính xác trước khi áp dụng logic lọc ở truy vấn bên ngoài.

Tóm lại, trong SQL nâng cao, Truy vấn Con là cầu nối không thể thiếu, cho phép nhà khoa học dữ liệu sử dụng logic lọc trên các cột được tạo ra bởi Hàm Cửa sổ, qua đó khai thác toàn bộ sức mạnh của các hàm này trong việc tạo ra các tập dữ liệu phân tích phức tạp.